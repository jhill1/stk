#!/usr/bin/env python
#
#    Supertree Toolkit. Software for managing and manipulating sources
#    trees ready for supretree construction.
#    Copyright (C) 2011, Jon Hill, Katie Davis
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Jon Hill. jon.hill@imperial.ac.uk. 

import os
import sys
import math
import numpy 
import argparse
stk_path = os.path.join( os.path.realpath(os.path.dirname(__file__)), os.pardir )
sys.path.insert(0, stk_path)
stk_path = os.path.join( os.path.realpath(os.path.dirname(__file__)), os.pardir ,os.pardir)
sys.path.insert(0, stk_path)
import stk.supertree_toolkit as supertree_toolkit
import stk.stk_import_export as supertree_import_export
from stk.stk_exceptions import *
import stk.Getch as Getch
import string

# Set up a global Getch class for all functions to use
inkey = Getch._Getch()

# STK is the main command line program for the supertree toolkit
# Using the XML files created by the GUI it can processes the data, without
# launching the GUI - useful for batch processing or tasks that might take a while.
def main():

    parser = argparse.ArgumentParser(
         prog="stk",
         description="""stk is the command line interface to the supertree toolkit. """+
                     """It can access all the functionality of the STK that is available in """+
                     """the GUI. """
                     )
    parser.add_argument(
            '-v', 
            '--verbose', 
            action='store_true', 
            help="Verbose output: mainly progress reports.",
            default=False
            )
    subparsers = parser.add_subparsers(help='sub-command help')

    # Here's how we add a new sub-command
    #
    # Add a subparser, with some help and a command
    parser_cm = subparsers.add_parser('create_matrix',
            help='Create a TNT or Nexus matrix'
            )
    # Now add the command line args for this command
    # These arguments are not-optional
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output matrix file')
    # This one is optional
    parser_cm.add_argument('-f',
            '--format', 
            choices=['hennig', 'nexus'],
            help='The format of the matrix. hennig or nexus. Default is hennig')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    # Set the function that gets called when the sub command is activated
    parser_cm.set_defaults(func=create_matrix)


    # substitue taxa command
    parser_cm = subparsers.add_parser('sub_taxa',
            help='Substitute or delete taxa from the file'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('-s',
            '--subs', 
            help='A substitution file. See manual for format.')
    parser_cm.add_argument('-n',
            '--newtaxon', 
            help='The new taxon. If you want to delete, leave blank.')
    parser_cm.add_argument('-o',
            '--oldtaxon', 
            help='The old taxon. Must be in the dataset.')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.set_defaults(func=sub_taxa)

    
    # import data command
    parser_cm = subparsers.add_parser('import_data',
            help='Import data from old STK dataset.'
            )
    parser_cm.add_argument('input',
            help='The input directory')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.set_defaults(func=import_data)


    # export data command
    parser_cm = subparsers.add_parser('export_data',
            help='Export data to old STK dataset.'
            )
    parser_cm.add_argument('input',
            help='The input file')
    parser_cm.add_argument('output', 
            help='The output directory')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing directory without asking for confirmation")
    parser_cm.set_defaults(func=export_data) 


    # export trees command
    parser_cm = subparsers.add_parser('export_trees',
            help='Export all tree in data to single tree file'
            )
    parser_cm.add_argument('input',
            help='The input Phyml file')
    parser_cm.add_argument('output', 
            help='The output tree file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing directory without asking for confirmation")
    # This one is optional
    parser_cm.add_argument('-f',
            '--format', 
            choices=["Nexus","Newick","tnt"],
            default="Nexus",
            help='The format of the tree file. Nexus, Newick or tnt. Default is Nexus')
    parser_cm.add_argument('--anonymous',
            '-a',
            action='store_true',
            default=False,
            help="Anonymise output file to remove source names. Only works for Nexus files; otherwise ignored.")
    parser_cm.set_defaults(func=export_trees) 

    # export trees command
    parser_cm = subparsers.add_parser('export_bib',
            help='Export all bibliographic data to a file'
            )
    parser_cm.add_argument('input',
            help='The input Phyml file')
    parser_cm.add_argument('output', 
            help='The output bibliographic file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing directory without asking for confirmation")
    # This one is optional
    parser_cm.add_argument('-f',
            '--format', 
            choices=["bibtex","latex","html","short","long","xml"],
            default="bibtex",
            help="""The format of the bibliographic file. Default is bibtex.
                    Choice is from bibtex, latex, html, short, long, xml."""
            )
    parser_cm.set_defaults(func=export_bib) 

    # Data summary command
    parser_cm = subparsers.add_parser('data_summary',
            help='Summary of this dataset'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('-o',
            '--output',
            default=False,
            const=True,
            nargs='?',
            help='Save output to a file, rather than to screen. '+
            'If no file is specified, the summary is saved to the input file directory '+
            'as "data_summary.txt" otherwise the given filename is used.')
    parser_cm.add_argument('-d',
            '--detailed',
            action='store_true',
            default=False,
            help="Output a detailed version of the summary")
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing files without asking for confirmation")
    parser_cm.set_defaults(func=data_summary)

    # Data summary command
    parser_cm = subparsers.add_parser('data_ind',
            help='Check the independence of source trees within this dataset.'
            )
    # Now add the command line args for this command
    # These arguments are not-optional
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing files without asking for confirmation")
    parser_cm.add_argument('-o',
            '--output',
            default=False,
            const=True,
            nargs='?',
            required=False,
            help='Save output to a file, rather than to screen. '+
            'If no file is specified, the summary is saved to the input file directory '+
            'as "data_ind.txt" otherwise the given filename is used. See the manual on how to '+
            'interpret these files.')
    parser_cm.add_argument('-n',
            '--newphyml', 
            required=False,
            help='Provide a new PHYML file with the trees that are a subset of other trees removed. The ' +
            'trees that are identical to other trees are still in the data. Please provide a filename.')
    # Set the function that gets called when the sub command is activated
    parser_cm.set_defaults(func=data_ind)


    # Data overlap command
    parser_cm = subparsers.add_parser('data_overlap',
            help='Check these data are sufficiently well connected'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('-n',
            '--number_overlap',
            type=int,
            help="Number of taxa in common for two trees to be connected. Default is 2.",
            required=False,
            )
    parser_cm.add_argument('-g',
            '--graphic',
            default=False,
            const=True,
            nargs='?',
            help='Save a graphical representation of the connectivity. This is in the form of a graph. '+
            'You can specifiy a file name, or a filename will be automatically generated for you and '+
            'saved in the same directory as the input file. A key.csv file will also be generated.')
    parser_cm.add_argument('-d',
            '--detailed',
            action='store_true',
            default=False,
            help="Output a detailed version of the graph. For more than 200 source trees this could take a while.")
    parser_cm.set_defaults(func=data_overlap)


    # Permute trees command
    parser_cm = subparsers.add_parser('permute_trees',
            help='Create all possible trees from sources that contain non-monophyly. See manual for details.'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output tree or matrix file(s). If multiple files are produced the sourcename will be appended to the filename.')
    parser_cm.add_argument('-c',
            '--create_matrix',
            choices=['','hennig', 'nexus'],
            help="Create a matrix of the given format for all permutable trees in the input file. Default is hennig",
            required=False,
            default='hennig',
            )
    parser_cm.add_argument('-t',
            '--treefile',
            choices=['','Nexus','Newick','tnt'],
            help="Create a tree file of the given format for all permutable trees in the input file. Default is nexus",
            required=False,
            default='',
            )
    parser_cm.add_argument('-n',
            '--treename',
            default=None,
            help="Do the permutation on a single tree only. Format of the name is Sourcename_treenumber, e.g. 'Hill_2011_1'",
            required=False,
            )
    parser_cm.set_defaults(func=permute_trees)

    # parse the arguments, and strip out the common options
    args = parser.parse_args()
    verbose = args.verbose
    # All of the rest may or may not apply to the command chosen
    # The rest of this function is effectively checking all of the arguments
    # against the command specified
    # Each command is given a function to execute via the "set_default" argument
    args.func(args)


def data_ind(args):
    """ Check data independence
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    newphyml = args.newphyml
    overwrite = args.overwrite

    if (output_file == True):
        # output file is set, but no file given
        # set to default
        # grab directory from input file
        direc = os.path.dirname(input_file)
        output_file = direc + os.path.sep + "data_independence.txt"

    # check if output files are there
    if (output_file and os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break
    if (not newphyml == None and os.path.exists(newphyml) and not overwrite):
        print "Output Phyml file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)
    if (newphyml == None):
        data_independence = supertree_toolkit.data_independence(XML)
    else:
        data_independence, new_phyml = supertree_toolkit.data_independence(XML,make_new_xml=True)

    # process data
    data_ind = ""
    #column headers
    data_ind = "Source trees that are subsets of others\n"
    data_ind = data_ind + "Flagged tree, is a subset of:\n"
    for name in data_independence:
        if ( data_independence[name][1] == supertree_toolkit.SUBSET ):
            data_ind += name + "," + data_independence[name][0] + "\n"
    
    data_ind += "\n\nSource trees that are identical to others\n"
    data_ind = data_ind + "Flagged tree, is identical to:\n"
    for name in data_independence:
        if ( data_independence[name][1] == supertree_toolkit.IDENTICAL ):
            data_ind += name + "," + data_independence[name][0] + "\n"
        

    if (output_file == False or
        output_file == None):
        print data_ind
    else:
        f = open(output_file, "w")
        f.write(data_ind)
        f.close()

    if (not newphyml == None):
        f = open(newphyml,"w")
        f.write(new_phyml)
        f.close()

def data_summary(args):
    """ Create a data summary
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    detailed = args.detailed

    if (output_file == True):
        # output file is set, but no file given
        # set to default
        # grab directory from input file
        direc = os.path.dirname(input_file)
        output_file = direc + os.path.sep + "data_summary.txt"

    XML = supertree_toolkit.load_phyml(input_file)
    data_summary = supertree_toolkit.data_summary(XML,detailed=detailed)
    if (output_file == False or
        output_file == None):
        print data_summary
    else:
        f = open(output_file, "w")
        f.write(data_summary)
        f.close()

def create_matrix(args):
    """ This function creates a phylogenetic matrix from a PHYML file
        by obtaining the tree strings contained in the file. """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    f_format = args.format
    overwrite = args.overwrite
    
    # check all the options
    if (f_format == None):
        f_format = 'hennig'

    if (not f_format == 'nexus' and
        not f_format == 'hennig'):
        print "Format must be one of 'hennig' or 'nexus'"
        sys.exit(-1)

    # Does the input file exist?
    if (not os.path.exists(input_file)):
        print "Input file cannot be found. Exiting"
        sys.exit(-1)

    # Does the output file already exist?
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break



    XML = supertree_toolkit.load_phyml(input_file)
    matrix = supertree_toolkit.create_matrix(XML,format=f_format)
    f = open(output_file, "w")
    f.write(matrix)
    f.close()

def sub_taxa(args):
    """ Substitute or delete taxa from a PHYML file
    and make a new file with these taxa subbed/removed from all trees
    and XML
    """
    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    overwrite = args.overwrite
    subs_file = args.subs
    old_taxa = []
    new_taxa = []
    old_taxon = args.oldtaxon
    new_taxon = args.newtaxon
    
    # check all the options
    # We need either a subs file *or* an old taxon, but not both
    if (old_taxon == None and subs_file == None):
        print "You need to supply either a subs file or an old_taxon"
        sys.exit(-1)
    if (old_taxon != None and subs_file != None):
        print "You need to supply either a subs file or an old_taxon, not both"
        sys.exit(-1)

    if (old_taxon != None):
        old_taxa.append(old_taxon)
        if (new_taxon != None):
            new_taxa.append(new_taxon)

    if (subs_file):
        try:
            old_taxa, new_taxa = stk_._parse_subs_file(subs_file)
        except UnableToParseSubsFile as e:
            print e.msg
            sys.exit(-1)
    
    
    # Does the input file exist
    if (not os.path.exists(input_file)):
        print "Input file cannot be found. Exiting"
        sys.exit(-1)

    # Does the output file already exist?
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)
    XML = supertree_toolkit.substitute_taxa(XML,old_taxa,new_taxa)
    # Add an event to the history of the file
    XML = supertree_toolkit.add_historical_event(XML, "Taxa substituted using command: " +" ".join(sys.argv)) 
    f = open(output_file,'w')
    f.write(XML)

    sys.exit(0)

# Note data import is *not* perfect due:
#   - more data in the new format
#   - more detail in new format for fossil data
#   - more comments and notes
def import_data(args):
    """ Import old (directory based) STK data into a PHYML file.
        Note the data copy is not perfect.
    """
    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_dir = args.input
    overwrite = args.overwrite

    if (not os.path.exists(input_dir)):
        print "Input directory cannot be found. Exiting"
        sys.exit(-1)

    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    phyml = supertree_import_export.import_old_data(input_dir,verbose=verbose) 
    # Add an event to the history of the file
    phyml = supertree_toolkit.add_historical_event(phyml, "Data created using: "+ " ".join(sys.argv)) 
    f = open(output_file, "w")
    f.write(phyml)
    f.close()

def export_data(args):
    """ Export a PHYML to an old-style STK format (directory based).
    """
    # Parse the args
    verbose = args.verbose
    output_dir = args.output
    input_file = args.input

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    XML = supertree_toolkit.load_phyml(input_file)
    try:
        supertree_import_export.export_to_old(XML,output_dir,verbose=verbose) 
    except STKImportExportError as e:
        print e.msg


def data_overlap(args):
    """ Check the data are sufficient well connected in terms of their taxonomic overlap
    """

    verbose = args.verbose
    input_file = args.input
    output_file = None
    if args.number_overlap == None:
        overlap = 2
    else:
        overlap = args.number_overlap
    if args.graphic == None:
        graphic = False
    else:
        graphic = True
        if args.graphic == True:
            # generate filename
            filename =  os.path.splitext(input_file)[0]
            output_file = filename+"_"+str(overlap)+".pdf"
        else:
            output_file = args.graphic
            # check it ends in .png...
            extension = os.path.splitext(output_file)[1]
            if (not extension == '.png' or not extension == '.svg' or not extension == '.pdf'):
                print "Warning: unknown output format. Correcting the output file you gave to .pdf"
                output_file = os.path.splitext(output_file)[0]+".pdf"

    XML = supertree_toolkit.load_phyml(input_file)
    overlap_ok, key_list = supertree_toolkit.data_overlap(XML,  overlap_amount=overlap, filename=output_file, detailed=args.detailed, verbose=verbose)
    if (graphic):
        # generate key file
        filename =  os.path.splitext(input_file)[0]
        csv_file = filename+'_key_list_'+str(overlap)+".csv"
        i = 0
        f = open(csv_file,"w")
        for key in key_list:
            if type(key).__name__=='list':
                f.write(str(i)+","+",".join(key)+"\n")
            else:
                f.write(str(i)+","+key+"\n")
            i = i+1
        f.close()


def export_trees(args):
    """ Export source trees to a single tree file
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    format = args.format
    anon = args.anonymous
    overwrite = args.overwrite

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    # check if output files are there
    if (output_file and os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)

    output_string = supertree_toolkit.amalgamate_trees(XML,format=format,anonymous=anon)

    f = open(output_file,"w")
    f.write(output_string)
    f.close()

def export_bib(args):
    """ Export bibliographic information to a file
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    format = args.format
    overwrite = args.overwrite

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    # check if output files are there
    if (output_file and os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)

    output_string = supertree_toolkit.export_bibliography(XML,output_file,format=format)

def permute_trees(args):
    """ Create all possible permutations of permutable trees in the input file.
    Permutable trees have non-monophyletic taxa labelled with %d.
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    create_matrix = args.create_matrix
    treefile = args.treefile
    name = args.treename

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    XML = supertree_toolkit.load_phyml(input_file)

    tree_list = {}
    all_trees = supertree_toolkit.obtain_trees(XML)
    if (not name == None): # user has supplied a tree name - find it
        # get tree
        for t in all_trees:
            if t == name:
                tree_list[t] = all_trees[t]
        if (len(tree_list) == 0):
            print "Error finding that name. It should be in the form 'Hill_2011_1'"
            sys.exit(-1)
    else:
        # get all trees
        tree_list = supertree_toolkit._find_trees_for_permuting(XML)

    for t in tree_list:
        # permute
        if (not treefile == ''):
            output_string = supertree_toolkit.permute_tree(tree_list[t],treefile=treefile)
        else:
            output_string = supertree_toolkit.permute_tree(tree_list[t],matrix=create_matrix,treefile=None)

        #save
        new_output,ext = os.path.splitext(output_file)
        new_output += "_"+t+ext
        f = open(new_output,'w')
        f.write(output_string)
        f.close
            

if __name__ == "__main__":
    main()


