#!/usr/bin/env python
#
#    Supertree Toolkit. SOftware for managing and manipulating sources
#    trees ready for supretree construction.
#    Copyright (C) 2011, Jon Hill, Katie Davis
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Jon Hill. jon.hill@imperial.ac.uk. 

import os
import sys
import math
import numpy 
import argparse
stk_path = os.path.join( os.path.realpath(os.path.dirname(__file__)), os.pardir )
sys.path.insert(0, stk_path)
stk_path = os.path.join( os.path.realpath(os.path.dirname(__file__)), os.pardir ,os.pardir)
sys.path.insert(0, stk_path)
import stk.supertree_toolkit as supertree_toolkit
import stk.stk_import_export as supertree_import_export


# STK is the main command line program for the supertree toolkit
# Using the XML files created by the GUI it can processes the data, without
# launching the GUI - useful for batch processing or tasks that might take a while.
def main():

    parser = argparse.ArgumentParser(
         prog="stk",
         description="""stk is the command line interface to the supertree toolkit. """+
                     """It can access all the functionality of the STK that is available in """+
                     """the GUI. """
                     )
    parser.add_argument(
            '-v', 
            '--verbose', 
            action='store_true', 
            help="Verbose output: mainly progress reports.",
            default=False
            )
    subparsers = parser.add_subparsers(help='sub-command help')

    # Here's how we add a new sub-command
    #
    # Add a subparser, with some help and a command
    parser_cm = subparsers.add_parser('create_matrix',
            help='Create a TNT or Nexus matrix'
            )
    # Now add the command line args for this command
    # These arguments are not-optional
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output matrix file')
    # This one is optional
    parser_cm.add_argument('-f',
            '--format', 
            choices=['hennig', 'nexus'],
            help='The format of the matrix. hennig or nexus. Default is hennig')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the exisitng file without asking for confirmation")
    # Set the function that gets called when the sub command is activated
    parser_cm.set_defaults(func=create_matrix)


    parser_cm = subparsers.add_parser('sub_taxa',
            help='Substitute or delete taxa from the file'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('-s',
            '--subs', 
            help='A substitution file. See manual for format.')
    parser_cm.add_argument('-n',
            '--newtaxon', 
            help='The new taxon. If you want to delete, leave blank.')
    parser_cm.add_argument('-o',
            '--oldtaxon', 
            help='The old taxon. Must be in the dataset.')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the exisitng file without asking for confirmation")
    parser_cm.set_defaults(func=sub_taxa)

    
    parser_cm = subparsers.add_parser('import_data',
            help='Import data from old STK dataset.'
            )
    parser_cm.add_argument('input',
            help='The input directory')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the exisitng file without asking for confirmation")
    parser_cm.set_defaults(func=import_data)


    parser_cm = subparsers.add_parser('export_data',
            help='Export data to old STK dataset.'
            )
    parser_cm.add_argument('input',
            help='The input file')
    parser_cm.add_argument('output', 
            help='The output directory')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the exisitng directory without asking for confirmation")
    parser_cm.set_defaults(func=export_data) 


    # Data summary command
    parser_cm = subparsers.add_parser('data_summary',
            help='Summary of this dataset'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('-o',
            '--output',
            default=False,
            const=True,
            nargs='?',
            help='Save output to a file, rather than to screen. '+
            'If no file is specified, the summary is saved to the input file directory '+
            'as "data_summary.txt" otherwise the given filename is used.')
    parser_cm.add_argument('-d',
            '--detailed',
            action='store_true',
            default=False,
            help="Output a detailed version of the summary")
    parser_cm.set_defaults(func=data_summary)


    # parse the arguments, and strip out the common options
    args = parser.parse_args()
    verbose = args.verbose
    # All of the rest may or may not apply to the command chosen
    # The rest of this function is effectively checking all of the arguments
    # against the command specified
    # Each command is given a function to execute via the "set_default" argument
    args.func(args)

def data_summary(args):
    """ Create a data summary
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    detailed = args.detailed

    if (output_file == True):
        # output file is set, but no file given
        # set to default
        # grab directory from input file
        direc = os.path.dirname(input_file)
        output_file = direc + os.path.sep + "data_summary.txt"

    XML = supertree_toolkit.load_phyml(input_file)
    data_summary = supertree_toolkit.data_summary(XML,detailed=detailed)
    if (output_file == False or
        output_file == None):
        print data_summary
    else:
        f = open(output_file, "w")
        f.write(data_summary)
        f.close()
        


def create_matrix(args):
    """ This function creates a phylogenetic matrix from a PHYML file
        by obtaining the tree strings contained in the file. """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    f_format = args.format
    overwrite = args.overwrite
    
    # check all the options
    if (f_format == None):
        f_format = 'hennig'

    if (not f_format == 'nexus' and
        not f_format == 'hennig'):
        print "Format must be one of 'hennig' or 'nexus'"
        sys.exit(-1)

    # Does the input file exist?
    if (not os.path.exists(input_file)):
        print "Input file cannot be found. Exiting"
        sys.exit(-1)

    # Does the output file already exist?
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            input = sys.stdin.read(1)
            if input == None:
                input = 'y'
            if input == 'n':
                print "Exiting..."
                sys.exit(0)
            if input == 'y':
                break


    XML = supertree_toolkit.load_phyml(input_file)
    matrix = supertree_toolkit.create_matrix(XML,format=f_format)
    f = open(output_file, "w")
    f.write(matrix)
    f.close()

def sub_taxa(args):
    """ Substitute or delete taxa from a PHYML file
    and make a new file with these taxa subbed/removed from all trees
    and XML
    """
    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    overwrite = args.overwrite
    subs_file = args.subs
    old_taxa = []
    new_taxa = []
    old_taxon = args.oldtaxon
    new_taxon = args.newtaxon
    
    # check all the options
    # We need either a subs file *or* an old taxon, but not both
    if (old_taxon == None and subs_file == None):
        print "You need to supply either a subs file or an old_taxon"
        sys.exit(-1)
    if (old_taxon != None and subs_file != None):
        print "You need to supply either a subs file or an old_taxon, not both"
        sys.exit(-1)

    if (old_taxon != None):
        old_taxa.append(old_taxon)
        if (new_taxon != None):
            new_taxa.append(new_taxon)

    if (subs_file):
        try:
            old_taxa, new_taxa = stk_._parse_subs_file(subs_file)
        except UnableToParseSubsFile as e:
            print e.msg
            sys.exit(-1)
    
    
    # Does the input file exist
    if (not os.path.exists(input_file)):
        print "Input file cannot be found. Exiting"
        sys.exit(-1)

    # Does the output file already exist?
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            input = sys.stdin.read(1)
            if input == None:
                input = 'y'
            if input == 'n':
                print "Exiting..."
                sys.exit(0)
            if input == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)
    XML = supertree_toolkit.substitute_taxa(XML,old_taxa,new_taxa)
    # Add an event to the history of the file
    XML = supertree_toolkit.add_historical_event(XML, "Taxa substituted using command: " +" ".join(sys.argv)) 
    f = open(output_file,'w')
    f.write(XML)

    sys.exit(0)

# Note data import is *not* perfect due:
#   - more data in the new format
#   - more detail in new format for fossil data
#   - more comments and notes
def import_data(args):
    """ Import old (directory based) STK data into a PHYML file.
        Note the data copy is not perfect.
    """
    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_dir = args.input
    overwrite = args.overwrite

    if (not os.path.exists(input_dir)):
        print "Input directory cannot be found. Exiting"
        sys.exit(-1)

    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue? [Y/n]"
        while True:
            input = sys.stdin.read(1)
            if input == None:
                input = 'y'
            if input == 'n':
                print "Exiting..."
                sys.exit(0)
            if input == 'y':
                break

    phyml = stk_import_export.import_old_data(input_dir,verbose=verbose) 
    # Add an event to the history of the file
    phyml = supertree_toolkit.add_historical_event(phyml, "Data created using: "+ " ".join(sys.argv)) 
    f = open(output_file, "w")
    f.write(phyml)
    f.close()

def export_data(args):
    """ Export a PHYML to an old-style STK format (directory based).
    """
    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input

    if (not os.path.exists(input)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    if (os.path.exists(output)):
        print "Output directory exists."
        sys.exit(-1)

    stk_import_export.export_to_old(input,output_dir,verbose=verbose) 

if __name__ == "__main__":
    main()
